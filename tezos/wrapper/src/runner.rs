// Copyright (c) SimpleStaking, Viable Systems and Tezedge Contributors
// SPDX-License-Identifier: MIT

use std::io::{self, BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::{Child, Command, Stdio};
use std::time::Duration;

use failure::Fail;
use nix::sys::signal;
use nix::sys::signal::Signal;
use nix::unistd::Pid;
use slog::{info, warn, Level, Logger};
use wait_timeout::ChildExt;

use crate::ProtocolEndpointConfiguration;

/// Errors generated by `protocol_runner`.
#[derive(Fail, Debug)]
pub enum ProtocolRunnerError {
    #[fail(
        display = "Failed to spawn tezos protocol wrapper sub-process: {}",
        reason
    )]
    SpawnError { reason: io::Error },
    #[fail(
        display = "Failed to terminate/kill tezos protocol wrapper sub-process, reason: {}",
        reason
    )]
    TerminateError { reason: String },
}

impl slog::Value for ProtocolRunnerError {
    fn serialize(
        &self,
        _record: &slog::Record,
        key: slog::Key,
        serializer: &mut dyn slog::Serializer,
    ) -> slog::Result {
        serializer.emit_arguments(key, &format_args!("{}", self))
    }
}

/// Control protocol runner sub-process.
#[derive(Clone)]
pub struct ExecutableProtocolRunner {
    sock_cmd_path: PathBuf,
    executable_path: PathBuf,
    endpoint_name: String,
    log_level: Level,
}

impl ExecutableProtocolRunner {
    /// Send SIGINT signal to the sub-process, which is cheking for this ctrl-c signal and shuts down gracefully if recieved
    fn terminate_or_kill(process: &mut Child, reason: String) -> Result<(), ProtocolRunnerError> {
        // try to send SIGINT (ctrl-c)
        match signal::kill(Pid::from_raw(process.id() as i32), Signal::SIGINT) {
            Ok(_) => Ok(()),
            Err(sigint_error) => {
                // (fallback) if SIGINT failed, we just kill process
                match process.kill() {
                    Ok(_) => Ok(()),
                    Err(kill_error) => Err(ProtocolRunnerError::TerminateError {
                        reason: format!(
                            "Reason for termination: {}, sigint_error: {}, kill_error: {}",
                            reason, sigint_error, kill_error
                        ),
                    }),
                }
            }
        }
    }

    /// Starts a new thread to read and lot the subprocess output
    fn log_subprocess_output(&self, process: &mut Child, log: Logger) {
        let stdout_log = log.clone();
        let stderr_log = log.clone();
        let stdout = process.stdout.take().unwrap();
        let stderr = process.stderr.take().unwrap();

        let stdout_logger = std::thread::Builder::new()
            .name(format!("{}-stdout-logger", self.endpoint_name))
            .spawn(move || {
                let stdout_reader = BufReader::new(stdout);
                stdout_reader
                    .lines()
                    .filter_map(|line| line.ok())
                    .for_each(|line| info!(stdout_log, "[OCaml-out] {}", line));
            });

        let stderr_logger = std::thread::Builder::new()
            .name(format!("{}-stderr-logger", self.endpoint_name))
            .spawn(move || {
                let stderr_reader = BufReader::new(stderr);
                stderr_reader
                    .lines()
                    .filter_map(|line| line.ok())
                    .for_each(|line| info!(stderr_log, "[OCaml-err] {}", line));
            });

        if let Err(err) = stdout_logger {
            warn!(
                log,
                "Failed to launch stdout logger thread for OCaml subprocess: {:?}", err
            );
        }

        if let Err(err) = stderr_logger {
            warn!(
                log,
                "Failed to launch stdout logger thread for OCaml subprocess: {:?}", err
            );
        }
    }
}

impl ProtocolRunner for ExecutableProtocolRunner {
    type Subprocess = Child;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration = Duration::from_secs(10);

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        endpoint_name: String,
    ) -> Self {
        let ProtocolEndpointConfiguration {
            executable_path,
            log_level,
            ..
        } = configuration;
        ExecutableProtocolRunner {
            sock_cmd_path: sock_cmd_path.to_path_buf(),
            executable_path,
            endpoint_name,
            log_level,
        }
    }

    fn spawn(&self, log: Logger) -> Result<Self::Subprocess, ProtocolRunnerError> {
        let mut process = Command::new(&self.executable_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .arg("--sock-cmd")
            .arg(&self.sock_cmd_path)
            .arg("--endpoint")
            .arg(&self.endpoint_name)
            .arg("--log-level")
            .arg(&self.log_level.as_str().to_lowercase())
            .spawn()
            .map_err(|err| ProtocolRunnerError::SpawnError { reason: err })?;

        self.log_subprocess_output(&mut process, log.clone());

        Ok(process)
    }

    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError> {
        match process.wait_timeout(wait_timeout) {
            Ok(Some(_exit_status)) => {
                // process exited, so we are ok
                Ok(())
            }
            Ok(None) => Self::terminate_or_kill(process, "wait timeout exceeded".to_string()),
            Err(e) => Self::terminate_or_kill(process, format!("{}", e)),
        }
    }

    fn is_running(process: &mut Self::Subprocess) -> bool {
        matches!(process.try_wait(), Ok(None))
    }
}

pub trait ProtocolRunner: Clone + Send + Sync {
    type Subprocess: Send;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration;

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        endpoint_name: String,
    ) -> Self;

    fn spawn(&self, log: Logger) -> Result<Self::Subprocess, ProtocolRunnerError>;

    /// Give [`wait_timeout`] time to stop process, and after that if tries to terminate/kill it
    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError>;

    /// Checks if process is running
    fn is_running(process: &mut Self::Subprocess) -> bool;
}
