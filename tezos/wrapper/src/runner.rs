// Copyright (c) SimpleStaking and Tezedge Contributors
// SPDX-License-Identifier: MIT

use std::io;
use std::path::{Path, PathBuf};
use std::process::{Child, Command};
use std::time::Duration;

use nix::sys::signal;
use nix::sys::signal::Signal;
use nix::unistd::Pid;
use slog::Level;
use thiserror::Error;
use wait_timeout::ChildExt;

use crate::ProtocolEndpointConfiguration;

/// Errors generated by `protocol_runner`.
#[derive(Error, Debug)]
pub enum ProtocolRunnerError {
    #[error("Failed to spawn tezos protocol wrapper sub-process: {reason}")]
    SpawnError { reason: io::Error },
    #[error("Failed to terminate/kill tezos protocol wrapper sub-process, reason: {reason}")]
    TerminateError { reason: String },
}

impl slog::Value for ProtocolRunnerError {
    fn serialize(
        &self,
        _record: &slog::Record,
        key: slog::Key,
        serializer: &mut dyn slog::Serializer,
    ) -> slog::Result {
        serializer.emit_arguments(key, &format_args!("{}", self))
    }
}

/// Control protocol runner sub-process.
#[derive(Clone)]
pub struct ExecutableProtocolRunner {
    sock_cmd_path: PathBuf,
    executable_path: PathBuf,
    endpoint_name: String,
    log_level: Level,
}

impl ExecutableProtocolRunner {
    /// Send SIGINT signal to the sub-process, which is cheking for this ctrl-c signal and shuts down gracefully if recieved
    fn terminate_or_kill(process: &mut Child, reason: String) -> Result<(), ProtocolRunnerError> {
        // try to send SIGINT (ctrl-c)
        match signal::kill(Pid::from_raw(process.id() as i32), Signal::SIGINT) {
            Ok(_) => Ok(()),
            Err(sigint_error) => {
                // (fallback) if SIGINT failed, we just kill process
                match process.kill() {
                    Ok(_) => Ok(()),
                    Err(kill_error) => Err(ProtocolRunnerError::TerminateError {
                        reason: format!(
                            "Reason for termination: {}, sigint_error: {}, kill_error: {}",
                            reason, sigint_error, kill_error
                        ),
                    }),
                }
            }
        }
    }
}

impl ProtocolRunner for ExecutableProtocolRunner {
    type Subprocess = Child;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration = Duration::from_secs(10);

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        endpoint_name: String,
    ) -> Self {
        let ProtocolEndpointConfiguration {
            executable_path,
            log_level,
            ..
        } = configuration;
        ExecutableProtocolRunner {
            sock_cmd_path: sock_cmd_path.to_path_buf(),
            executable_path,
            endpoint_name,
            log_level,
        }
    }

    fn spawn(&self) -> Result<Self::Subprocess, ProtocolRunnerError> {
        let process = Command::new(&self.executable_path)
            .arg("--sock-cmd")
            .arg(&self.sock_cmd_path)
            .arg("--endpoint")
            .arg(&self.endpoint_name)
            .arg("--log-level")
            .arg(&self.log_level.as_str().to_lowercase())
            .spawn()
            .map_err(|err| ProtocolRunnerError::SpawnError { reason: err })?;
        Ok(process)
    }

    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError> {
        match process.wait_timeout(wait_timeout) {
            Ok(Some(_exit_status)) => {
                // process exited, so we are ok
                Ok(())
            }
            Ok(None) => Self::terminate_or_kill(process, "wait timeout exceeded".to_string()),
            Err(e) => Self::terminate_or_kill(process, format!("{}", e)),
        }
    }

    fn is_running(process: &mut Self::Subprocess) -> bool {
        matches!(process.try_wait(), Ok(None))
    }
}

pub trait ProtocolRunner: Clone + Send + Sync {
    type Subprocess: Send;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration;

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        endpoint_name: String,
    ) -> Self;

    fn spawn(&self) -> Result<Self::Subprocess, ProtocolRunnerError>;

    /// Give [`wait_timeout`] time to stop process, and after that if tries to terminate/kill it
    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError>;

    /// Checks if process is running
    fn is_running(process: &mut Self::Subprocess) -> bool;
}
