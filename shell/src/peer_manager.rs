use std::collections::{HashMap, HashSet};
use std::net::SocketAddr;
use std::time::Duration;

use dns_lookup::LookupError;
use log::warn;
use riker::actors::*;

use networking::p2p::network_channel::NetworkChannelMsg;
use networking::p2p::network_manager::{NetworkManagerRef, ConnectToPeer};
use networking::p2p::peer::{PeerRef, Terminate};

/// Check peer threshold
struct CheckThreshold;

pub struct Threshold {
    low: usize,
    high: usize,
}

impl Threshold {
    pub fn new(low: usize, high: usize) -> Self {
        assert!(low <= high, "low must be less than or equal to high");
        Threshold { low, high }
    }

    pub fn mid_range(&self) -> usize {
        return self.low + ((self.high - self.low) / 2);
    }
}

#[actor(CheckThreshold)]
pub struct PeerManager {
    /// All events generated by the peer will end up in this channel
    event_channel: ChannelRef<NetworkChannelMsg>,
    network: NetworkManagerRef,
    threshold: Threshold,
    peers: HashMap<ActorUri, PeerRef>,
    bootstrap_addresses: Vec<String>,
    potential_peers: HashSet<SocketAddr>,
}

pub type PeerManagerRef = ActorRef<PeerManagerMsg>;

impl PeerManager {
    pub fn new(sys: &ActorSystem,
               event_channel: ChannelRef<NetworkChannelMsg>,
               network: NetworkManagerRef,
               bootstrap_addresses: &[String],
               threshold: Threshold) -> Result<PeerManagerRef, CreateError>
    {
        sys.actor_of(
            Props::new_args(PeerManager::actor, (event_channel, network, bootstrap_addresses)),
            PeerManager::name())
    }

    /// The `PeerManager` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "peer-manager"
    }

    fn actor((event_channel, bootstrap_addresses, network, threshold): (ChannelRef<NetworkChannelMsg>, Vec<String>, NetworkManagerRef, Threshold)) -> Self {
        PeerManager { event_channel, network, bootstrap_addresses, threshold, peers: HashMap::new(), potential_peers: HashSet::new() }
    }
}

impl Actor for PeerManager {
    type Msg = PeerManagerMsg;

    fn post_start(&mut self, ctx: &Context<Self::Msg>) {
        ctx.schedule(
            Duration::from_secs(4),
            Duration::from_secs(60),
            ctx.myself(),
            None,
            CheckThreshold.into());
    }

    fn sys_recv(&mut self, ctx: &Context<Self::Msg>, msg: SystemMsg, sender: Option<BasicActorRef>) {
        if let SystemMsg::Event(SystemEvent::ActorTerminated(evt)) = msg {
            self.peers.remove(evt.actor.uri())
        }
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<CheckThreshold> for PeerManager {
    type Msg = PeerManagerMsg;

    fn receive(&mut self, ctx: &Context<Self::Msg>, _msg: CheckThreshold, _sender: Sender) {
        if self.peers.len() < self.threshold.low {
            // request for more peers
            lookup_peers(&self.bootstrap_addresses).iter()
                .for_each(|address| self.network.tell(ConnectToPeer { address: address.clone() }, ctx.myself().into()))
        } else if self.peers.len() > self.threshold.high {
            // stop some peers
            self.peers.values()
                .take(self.peers.len() - self.threshold.high)
                .for_each(|peer| ctx.system.stop(peer.clone()))
        }
    }
}

fn lookup_peers(bootstrap_addresses: &[String]) -> Vec<SocketAddr> {
    let mut initial_peers = vec![];
    for address in bootstrap_addresses {
        match resolve_dns_name_to_peer_address(&address) {
            Ok(peers) => {
                initial_peers.extend(peers)
            },
            Err(e) => {
                warn!("DNS lookup for address: {:?} error: {:?}", &address, e)
            }
        }
    }
    Ok(initial_peers)
}

fn resolve_dns_name_to_peer_address(address: &str) -> Result<Vec<SocketAddr>, LookupError> {
    let addrs = dns_lookup::getaddrinfo(Some(address), None, None)?
        .filter(Result::is_ok)
        .filter_map(Result::unwrap)
        .map(|info| {
            info.sockaddr.set_port(9732);
            info.sockaddr
        })
        .collect();
    Ok(addrs)
}

