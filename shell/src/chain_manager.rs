use riker::actors::*;
use networking::p2p::network_channel::{NetworkChannelMsg, NetworkChannelTopic};
use networking::p2p::encoding::current_branch::CurrentBranchMessage;
use networking::p2p::peer::GetCurrentBranch;
use tezos_encoding::hash::{HashEncoding, HashType};

#[derive(Clone, Debug, Deserialize)]
struct Identity {
    peer_id: String,
    public_key: String,
    secret_key: String,
    proof_of_work_stamp: String,
}

#[derive(Clone, Debug)]
struct Balance;

#[actor(Balance)]
pub struct ChainManager {
    /// All events generated by the peer will end up in this channel
    event_channel: ChannelRef<NetworkChannelMsg>,

    current_branch: Option<CurrentBranchMessage> // TODO: this is totally incorrect, fix
}

impl Actor for ChainManager {
    type Msg = ChainManagerMsg;

    fn pre_start(&mut self, ctx: &Context<Self::Msg>) {
        self.event_channel.tell(Subscribe {
            actor: Box::new(ctx.myself()),
            topic: NetworkChannelTopic::NetworkEvents.into() }, None);
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<Balance> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, ctx: &Context<Self::Msg>, _msg: Balance, _sender: Sender) {
        // ...
    }
}

impl Receive<NetworkChannelMsg> for ChainManager {
    type Msg = PeerManagerMsg;

    fn receive(&mut self, ctx: &Context<Self::Msg>, msg: NetworkChannelMsg, sender: Sender) {
        if let NetworkChannelMsg::PeerBootstrapped(msg) = msg {
            msg.peer.tell(GetCurrentBranch { chain_id: genesis_chain_id() }, None);
        }
    }
}

pub fn genesis_chain_id() -> Vec<u8> {
    HashEncoding::new(HashType::ChainId).string_to_bytes("NetXgtSLGNJvNye").unwrap()
}