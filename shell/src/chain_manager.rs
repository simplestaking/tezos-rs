use std::collections::{HashMap, HashSet};
use std::time::{Duration, Instant};

use log::debug;
use riker::actors::*;

use networking::p2p::binary_message::MessageHashError;
use networking::p2p::encoding::prelude::*;
use networking::p2p::network_channel::NetworkChannelMsg;
use networking::p2p::peer::{PeerRef, SendMessage};
use storage::block_storage::BlockStorage;
use tezos_encoding::hash::{BlockHash, HashEncoding, HashType};

use crate::{remove_terminated_actor, subscribe_to_actor_terminated, subscribe_to_network_events};

const PEER_QUEUE_MAX: usize = 10;

#[derive(Clone, Debug)]
pub struct CheckChainCompleteness;

#[actor(CheckChainCompleteness, NetworkChannelMsg, SystemEvent)]
pub struct ChainManager {
    /// All events generated by the peer will end up in this channel
    event_channel: ChannelRef<NetworkChannelMsg>,
    /// Holds the state of all peers
    peers: HashMap<ActorUri, PeerState>,
    /// Holds state of the chain
    chain: ChainState,
}

pub type ChainManagerRef = ActorRef<ChainManagerMsg>;

impl ChainManager {
    pub fn actor(sys: &impl ActorRefFactory, event_channel: ChannelRef<NetworkChannelMsg>) -> Result<ChainManagerRef, CreateError> {
        sys.actor_of(
            Props::new_args(ChainManager::new, event_channel),
            ChainManager::name())
    }

    /// The `ChainManager` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "chain-manager"
    }

    fn new(event_channel: ChannelRef<NetworkChannelMsg>) -> Self {
        ChainManager { event_channel, chain: ChainState::new(), peers: HashMap::new() }
    }
}

impl Actor for ChainManager {
    type Msg = ChainManagerMsg;

    fn pre_start(&mut self, ctx: &Context<Self::Msg>) {
        subscribe_to_actor_terminated(ctx.system.sys_events(), ctx.myself());
        subscribe_to_network_events(&self.event_channel, ctx.myself());

        ctx.schedule::<Self::Msg, _>(
            Duration::from_secs(15),
            Duration::from_secs(60),
            ctx.myself(),
            None,
            CheckChainCompleteness.into());
    }

    fn sys_recv(&mut self, ctx: &Context<Self::Msg>, msg: SystemMsg, sender: Option<BasicActorRef>) {
        if let SystemMsg::Event(evt) = msg {
            self.receive(ctx, evt, sender);
        }
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<SystemEvent> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, msg: SystemEvent, _sender: Option<BasicActorRef>) {
        remove_terminated_actor(&msg, &mut self.peers)
    }
}

impl Receive<CheckChainCompleteness> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, _msg: CheckChainCompleteness, _sender: Sender) {
        debug!("Checking chain state");
        let ChainManager { peers, chain, .. } = self;

        if !chain.missing_blocks.is_empty() {
            debug!("Chain is not complete");
            peers.iter_mut()
                .for_each(|(_, peer)| {
                    let rr_delta = peer.rr_delta();
                    if (rr_delta < PEER_QUEUE_MAX) && !chain.missing_blocks.is_empty() {
                        let limit = PEER_QUEUE_MAX - rr_delta;
                        let get_block_headers = chain.move_to_queue(limit);
                        if !get_block_headers.is_empty() {
                            debug!("Requesting {} blocks from peer {}", get_block_headers.len(), &peer.peer_ref);
                            let msg = GetBlockHeadersMessage { get_block_headers };
                            tell_peer(msg.into(), peer);
                        }
                    }
                })
        } else {
            debug!("Chain is complete");
        }
    }
}

impl Receive<NetworkChannelMsg> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, msg: NetworkChannelMsg, _sender: Sender) {
        match msg {
            NetworkChannelMsg::PeerBootstrapped(msg) => {
                debug!("Requesting current branch from peer: {}", &msg.peer);
                let mut peer = PeerState::new(msg.peer);
                tell_peer(GetCurrentBranchMessage::new(genesis_chain_id()).into(), &mut peer);
                // store peer
                self.peers.insert(peer.peer_ref.uri().clone(), peer);
            }
            NetworkChannelMsg::PeerMessageReceived(received) => {
                match self.peers.get_mut(received.peer.uri()) {
                    Some(peer) => {
                        peer.inc_response();

                        let messages = &received.message.messages;
                        messages.iter()
                            .for_each(|message| match message {
                                PeerMessage::CurrentBranch(message) => {
                                    debug!("Received current branch from peer: {}", &received.peer);
                                    message.current_branch.history.iter()
                                        .for_each(|block_hash| self.chain.schedule_block_hash(block_hash.clone()))
                                }
                                PeerMessage::GetCurrentBranch(_) => {
                                    debug!("Current branch requested by peer: {}", &received.peer);
                                    // .. ignore
                                }
                                PeerMessage::BlockHeader(message) => {
                                    debug!("Received block header from peer: {}", &received.peer);
                                    self.chain.insert_block_header(message.block_header.clone()).expect("Failed to store block header");
                                }
                                _ => debug!("Ignored message: {:?}", message)
                            })
                    }
                    None => debug!("Received message for non-existing peer: {}", &received.peer)
                }
            }
            _ => (),
        }
    }
}

pub fn genesis_chain_id() -> Vec<u8> {
    HashEncoding::new(HashType::ChainId).string_to_bytes("NetXgtSLGNJvNye").unwrap()
}

struct PeerState {
    peer_ref: PeerRef,
    request_count: usize,
    request_last: Instant,
    response_count: usize,
    response_last: Instant,
}

impl PeerState {
    fn new(peer_ref: PeerRef) -> Self {
        PeerState {
            peer_ref,
            request_count: 0,
            request_last: Instant::now(),
            response_count: 0,
            response_last: Instant::now(),
        }
    }

    fn inc_request(&mut self) {
        self.request_count += 1;
        self.request_last = Instant::now();
    }

    fn inc_response(&mut self) {
        self.response_count += 1;
        self.response_last = Instant::now();
    }

    fn rr_delta(&self) -> usize {
        if self.response_count > self.request_count {
            self.response_count - self.request_count
        } else {
            0
        }
    }
}

struct ChainState {
    block_store: BlockStorage,
    missing_blocks: HashSet<BlockHash>,
}

impl ChainState {
    pub fn new() -> Self {
        ChainState {
            block_store: BlockStorage::new(),
            missing_blocks: HashSet::new(),
        }
    }

    pub fn insert_block_header(&mut self, block: BlockHeader) -> Result<(), MessageHashError> {
        // check if we already have seen predecessor
        if !self.block_store.is_present(&block.predecessor) {
            // block was not seen before
            self.missing_blocks.insert(block.predecessor.clone());
        }
        // store block
        let block_hash = self.block_store.insert(block)?;
        // remove from missing blocks
        self.missing_blocks.remove(&block_hash);
        Ok(())
    }

    pub fn schedule_block_hash(&mut self, block_hash: BlockHash) {
        if !self.block_store.is_present(&block_hash) {
            self.missing_blocks.insert(block_hash);
        }
    }

    pub fn move_to_queue(&mut self, n: usize) -> Vec<BlockHash> {
        self.missing_blocks.drain()
            .take(n)
            .collect()
    }
}

fn tell_peer(msg: PeerMessageResponse, peer: &mut PeerState) {
    peer.peer_ref.tell(SendMessage::new(msg), None);
    peer.inc_request();
}