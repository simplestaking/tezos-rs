use log::debug;
use riker::actors::*;

use networking::p2p::encoding::current_branch::{CurrentBranchMessage, GetCurrentBranchMessage};
use networking::p2p::encoding::peer::PeerMessage;
use networking::p2p::network_channel::{NetworkChannelMsg, NetworkChannelTopic};
use networking::p2p::peer::SendMessage;
use tezos_encoding::hash::{HashEncoding, HashType};

#[derive(Clone, Debug)]
pub struct Balance;

#[actor(Balance, NetworkChannelMsg)]
pub struct ChainManager {
    /// All events generated by the peer will end up in this channel
    event_channel: ChannelRef<NetworkChannelMsg>,

    current_branch: Option<CurrentBranchMessage> // TODO: this is totally incorrect, fix
}

pub type ChainManagerRef = ActorRef<ChainManagerMsg>;

impl ChainManager {

    pub fn actor(sys: &impl ActorRefFactory, event_channel: ChannelRef<NetworkChannelMsg>) -> Result<ChainManagerRef, CreateError> {
        sys.actor_of(
            Props::new_args(ChainManager::new, event_channel),
            ChainManager::name())
    }

    /// The `ChainManager` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "chain-manager"
    }

    fn new(event_channel: ChannelRef<NetworkChannelMsg>) -> Self {
        ChainManager { event_channel, current_branch: None }
    }
}

impl Actor for ChainManager {
    type Msg = ChainManagerMsg;

    fn pre_start(&mut self, ctx: &Context<Self::Msg>) {
        self.event_channel.tell(
            Subscribe {
                actor: Box::new(ctx.myself()),
                topic: NetworkChannelTopic::NetworkEvents.into(),
            }, None);
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<Balance> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, _msg: Balance, _sender: Sender) {
        // ...
    }
}

impl Receive<NetworkChannelMsg> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, msg: NetworkChannelMsg, _sender: Sender) {
        match msg {
            NetworkChannelMsg::PeerBootstrapped(msg) => {
                debug!("Requesting current branch from peer: {}", &msg.peer);
                msg.peer
                    .tell(SendMessage::new(PeerMessage::GetCurrentBranch(GetCurrentBranchMessage::new(genesis_chain_id())).into()), None);
            },
            NetworkChannelMsg::PeerMessageReceived(received) => {
                debug!("Received current branch from peer: {}", &received.peer);
                received.message.get_messages().iter()

                    .for_each(|message| match message {
                        PeerMessage::CurrentBranch(message) => {
                            self.current_branch = Some(message.clone());
                        }
                        PeerMessage::GetCurrentBranch(_message) => {
                            // .. ignore
                        }
                        _ => debug!("Ignored message: {:?}", message),
                    })
            },
            _ => (),
        }
    }
}

pub fn genesis_chain_id() -> Vec<u8> {
    HashEncoding::new(HashType::ChainId).string_to_bytes("NetXgtSLGNJvNye").unwrap()
}