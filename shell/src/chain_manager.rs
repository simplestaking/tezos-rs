use std::collections::{HashMap, HashSet};

use log::debug;
use riker::actors::*;

use networking::p2p::binary_message::MessageHashError;
use networking::p2p::encoding::current_branch::GetCurrentBranchMessage;
use networking::p2p::encoding::peer::PeerMessage;
use networking::p2p::encoding::prelude::*;
use networking::p2p::network_channel::{NetworkChannelMsg, NetworkChannelTopic};
use networking::p2p::peer::{PeerRef, SendMessage};
use storage::block_storage::BlockStorage;
use tezos_encoding::hash::{BlockHash, HashEncoding, HashType};

#[derive(Clone, Debug)]
pub struct CheckChainCompleteness;

#[actor(CheckChainCompleteness, NetworkChannelMsg)]
pub struct ChainManager {
    /// All events generated by the peer will end up in this channel
    event_channel: ChannelRef<NetworkChannelMsg>,
    peers: HashMap<ActorUri, PeerRef>,
    chain_state: ChainState
}

pub type ChainManagerRef = ActorRef<ChainManagerMsg>;

impl ChainManager {

    pub fn actor(sys: &impl ActorRefFactory, event_channel: ChannelRef<NetworkChannelMsg>) -> Result<ChainManagerRef, CreateError> {
        sys.actor_of(
            Props::new_args(ChainManager::new, event_channel),
            ChainManager::name())
    }

    /// The `ChainManager` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "chain-manager"
    }

    fn new(event_channel: ChannelRef<NetworkChannelMsg>) -> Self {
        ChainManager { event_channel, chain_state: ChainState::new(), peers: HashMap::new() }
    }
}

impl Actor for ChainManager {
    type Msg = ChainManagerMsg;

    fn pre_start(&mut self, ctx: &Context<Self::Msg>) {
        self.event_channel.tell(
            Subscribe {
                actor: Box::new(ctx.myself()),
                topic: NetworkChannelTopic::NetworkEvents.into(),
            }, None);
    }

    fn sys_recv(&mut self, _ctx: &Context<Self::Msg>, msg: SystemMsg, _sender: Option<BasicActorRef>) {
        if let SystemMsg::Event(SystemEvent::ActorTerminated(evt)) = msg {
            self.peers.remove(evt.actor.uri());
        }
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

impl Receive<CheckChainCompleteness> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, _msg: CheckChainCompleteness, _sender: Sender) {
        // ...
    }
}

impl Receive<NetworkChannelMsg> for ChainManager {
    type Msg = ChainManagerMsg;

    fn receive(&mut self, _ctx: &Context<Self::Msg>, msg: NetworkChannelMsg, _sender: Sender) {
        match msg {
            NetworkChannelMsg::PeerBootstrapped(msg) => {
                debug!("Requesting current branch from peer: {}", &msg.peer);
                msg.peer.tell(SendMessage::new(PeerMessage::GetCurrentBranch(GetCurrentBranchMessage::new(genesis_chain_id())).into()), None);
                self.peers.insert(msg.peer.uri().clone(), msg.peer);
            },
            NetworkChannelMsg::PeerMessageReceived(received) => {
                let messages = &received.message.messages;
                messages.iter()
                    .for_each(|message| match message {
                        PeerMessage::CurrentBranch(message) => {
                            debug!("Received current branch from peer: {}", &received.peer);
                            message.current_branch.history.iter()
                                .for_each(|block_hash| self.chain_state.schedule_block_hash(block_hash.clone()))
                        }
                        PeerMessage::GetCurrentBranch(_) => {
                            debug!("Current branch requested by peer: {}", &received.peer);
                            // .. ignore
                        }
                        PeerMessage::BlockHeader(message) => {
                            debug!("Received block header from peer: {}", &received.peer);
                            self.chain_state.insert_block_header(message.block_header.clone()).expect("Failed to store block header");
                        }
                        _ => debug!("Ignored message: {:?}", message)
                    })
            },
            _ => (),
        }
    }
}

pub fn genesis_chain_id() -> Vec<u8> {
    HashEncoding::new(HashType::ChainId).string_to_bytes("NetXgtSLGNJvNye").unwrap()
}

// TODO: implement algo
struct PeerState {
    peer_ref: PeerRef,

}

struct ChainState {
    block_store: BlockStorage,
    missing_blocks: HashSet<BlockHash>,
}

impl ChainState {

    pub fn new() -> Self {
        ChainState {
            block_store: BlockStorage::new(),
            missing_blocks: HashSet::new()
        }
    }

    pub fn insert_block_header(&mut self, block: BlockHeader) -> Result<(), MessageHashError> {
        // check if we already have seen predecessor
        if !self.block_store.is_present(block.get_predecessor()) {
            // block was not seen before
            self.missing_blocks.insert(block.get_predecessor().clone());
        }
        // store block
        let block_hash = self.block_store.insert(block)?;
        // remove from missing blocks
        self.missing_blocks.remove(&block_hash);
        Ok(())
    }

    pub fn schedule_block_hash(&mut self, block_hash: BlockHash) {
        if !self.block_store.is_present(&block_hash) {
            self.missing_blocks.insert(block_hash);
        }
    }

    pub fn move_to_queue(&mut self, n: usize) -> Vec<BlockHash> {
        self.missing_blocks.drain()
            .take(n)
            .collect()
    }
}

